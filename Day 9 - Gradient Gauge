/*
====================================================
ðŸ”§ Battery Simulation â€“ Enhanced from Day 9 Mission
====================================================

ðŸ“ Key Differences from Day 9:
1. ðŸ“ˆ Real Battery Charge Accumulation:
   - Uses a photoresistor to **gradually accumulate charge** over time.
   - Charge is stored in `battery_level` and mapped to 0â€“100% battery.

2. ðŸŒˆ Custom LED Behavior:
   - 0â€“25%: **Flashing Red Alert** (same as Day 9).
   - 26â€“70%: **Amber Gradient** (Red fades 255â†’128, Green rises 0â†’128).
   - 71â€“100%: **Green Gradient** (Red fades 128â†’0, Green rises 128â†’255).
   - **Improved gradient** over Day 9â€™s fixed color zones.

3. ðŸš¨ Flash Bug Fix:
   - Resolved **green flash glitch** around 25% using LED reset and safe mapping.
   - All RGB values are **constrained to 0â€“255** to avoid illegal PWM outputs.

4. âš¡ Fully Charged Message:
   - Displays **â€œBattery Fully Chargedâ€** once at 100% (like Day 9), but with enhanced flag logic.

5. ðŸ’¡ Code Modularity:
   - Flash logic is now in a **separate function** (`flashRedAlert()`) for clarity and reuse.
====================================================
*/

#define RED_PIN 11
#define GREEN_PIN 10
#define BLUE_PIN 9
#define PHOTORESISTOR_PIN A0

#define BATTERY_CAPACITY 50000UL
unsigned long battery_level = 0;
bool fullyChargedMessageShown = false;

void setup() {
  pinMode(RED_PIN, OUTPUT);
  pinMode(GREEN_PIN, OUTPUT);
  pinMode(BLUE_PIN, OUTPUT);
  pinMode(PHOTORESISTOR_PIN, INPUT);

  Serial.begin(9600);
  Serial.println("Simulated Charging Initiated: Final Patch Applied...");
}

void loop() {
  int lightValue = analogRead(PHOTORESISTOR_PIN);
  battery_level += lightValue;

  if (battery_level > BATTERY_CAPACITY) {
    battery_level = BATTERY_CAPACITY;
  }

  float percentage = ((float)battery_level / (float)BATTERY_CAPACITY) * 100;

  displayColor(0, 0, 0);  // Reset LED OFF to prevent ghosting

  int redValue = 0;
  int greenValue = 0;

  if (percentage < 100.0) {
    if (percentage <= 25.0) {
      redValue = 255;
      greenValue = 0;

      flashRedAlert();  // Flashing red for low battery

      Serial.print("Battery CRITICAL: ");
    } else if (percentage > 25.0 && percentage <= 70.0) {
      // Amber: Red 255â†’128, Green 0â†’128 with safe values
      redValue = constrain(map(percentage, 26, 70, 255, 128), 0, 255);
      greenValue = constrain(map(percentage, 26, 70, 0, 128), 0, 255);

      displayColor(redValue, greenValue, 0);
      delay(250);

      Serial.print("Battery Amber: ");
    } else {
      // Green: Red 128â†’0, Green 128â†’255 with safe values
      redValue = constrain(map(percentage, 71, 100, 128, 0), 0, 255);
      greenValue = constrain(map(percentage, 71, 100, 128, 255), 0, 255);

      displayColor(redValue, greenValue, 0);
      delay(250);

      Serial.print("Battery Green: ");
    }

    // Serial readout
    Serial.print(percentage, 1);
    Serial.print("% | Red: ");
    Serial.print(redValue);
    Serial.print(" | Green: ");
    Serial.print(greenValue);
    Serial.print(" | Light: ");
    Serial.println(lightValue);

    fullyChargedMessageShown = false;  // Reset message if not full
  } else {
    // Fully charged
    if (!fullyChargedMessageShown) {
      Serial.println("âš¡ Battery Fully Charged! All systems GO! âš¡");
      fullyChargedMessageShown = true;
    }

    displayColor(0, 255, 0);  // Solid green
    delay(500);
  }
}

// Flashing red function for clarity
void flashRedAlert() {
  displayColor(0, 0, 0);  // OFF
  delay(100);
  displayColor(255, 0, 0);  // RED ON
  delay(200);
  displayColor(0, 0, 0);  // OFF again
  delay(100);
}

void displayColor(byte red_intensity, byte green_intensity, byte blue_intensity) {
  analogWrite(RED_PIN, red_intensity);
  analogWrite(GREEN_PIN, green_intensity);
  analogWrite(BLUE_PIN, blue_intensity);
}
